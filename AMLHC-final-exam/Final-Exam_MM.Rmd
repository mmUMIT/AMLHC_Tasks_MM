---
title: "Final Exam"
author: "Melvin van der Mark"
date: "27-June-2024"
output: 
  rmdformats::material:
    use_bookdown: TRUE
    highlight: TRUE
    lightbox: TRUE

    
---

# Introduction

Precision medicine is becoming increasinly relevant in the field of oncology. Comprehensive genomic profiling (CGP) allows for the detailed analysis of tumor tissue. New methods such as next-generation sequencing (NGS) can identify various type of alterations such as: mutations, amplifications, rearragements, fusions and more. The identification of these alterations can help with treatment decisions in the field of targeted therapy. These therapies target the specific alterations found.

# Data Description

The dataset used contains alterations found for different cancer diagnoses, all patients with solid tumor types were included in the dataset. Gene testing for hematological cancer types to exist, but are not covered in this dataset. The patients were recruited between 2016 and 2022. In addition, the dataset includes other variables such as age, gender, year of birth, date of test, date of result, and test panel. 

## Test 

All the patients were tested with the same NGS test using CGP by exploring 323 genes in samples from the tumor. The test were conducted from 2016 - 2022 to get the most relevant results. A number of alterations have related systemtherapies which are then recommended based on not just the gene alteration but also the diagnosis and other factors. 

## Gene panel

ABL1, ABL2, ACVR1B, AKT1, AKT2, AKT3, ALK, AMER1 (FAM123B), APC, AR, ARAF, ARFRP1, ARID1A, ARID1B, ARID2, ASXL1, ATM, ATR, ATRX, AURKA, AURKB, AXIN1, AXL, BAP1, BARD1, BCL2, BCL2L1, BCL2L2, BCL6, BCOR, BCORL1, BCR, BLM, BRAF, BRCA1, BRCA2, BRD4, BRIP1, BTG1, BTK, C11orf30 (EMSY), CARD11, CBFB, CBL, CCND1, CCND2, CCND3, CCNE1, CD274, CD79A, CD79B, CDC73, CDH1, CDK12, CDK4, CDK6, CDK8, CDKN1A, CDKN1B, CDKN2A, CDKN2B, CDKN2C, CEBPA, CHD2, CHD4, CHEK1, CHEK2, CIC, CREBBP, CRKL, CRLF2, CSF1R, CTCF, CTNNA1, CTNNB1, CUL3, CYLD, DAXX, DDR2, DICER1, DNMT3A, DOT1L, EGFR, EP300, EPHA3, EPHA5, EPHA7, EPHB1, ERBB2, ERBB3, ERBB4, ERG, ERRFI1, ESR1, ETV1, ETV4, ETV5, ETV6, EZH2, FAM123B, FAM46C, FANCA, FANCC, FANCD2, FANCE, FANCF, FANCG, FANCL, FAS, FAT1, FBXW7, FGF10, FGF14, FGF19, FGF23, FGF3, FGF4, FGF6, FGFR1, FGFR2, FGFR3, FGFR4, FH, FLCN, FLT1, FLT3, FLT4, FOXL2, FOXP1, FRS2, FUBP1, GABRA6, GATA1, GATA2, GATA3, GATA4, GATA6, GID4 (C17orf39), GLI1, GNA11, GNA13, GNAQ, GNAS, GPR124, GRIN2A, GRM3, GSK3B, H3F3A, HGF, HNF1A, HRAS, HSD3B1, HSP90AA1, IDH1, IDH2, IGF1R, IGF2, IKBKE, IKZF1, IL7R, INHBA, INPP4B, IRF2, IRF4, IRS2, JAK1, JAK2, JAK3, JUN, KAT6A (MYST3), KDM5A, KDM5C, KDM6A, KDR, KEAP1, KEL, KIT, KLHL6, KMT2A (MLL), KMT2C (MLL3), KMT2D (MLL2), KRAS, LMO1, LRP1B, LYN, LZTR1, MAGI2, MAP2K1, MAP2K2, MAP2K4, MAP3K1, MCL1, MDM2, MDM4, MED12, MEF2B, MEN1, MET, MITF, MLH1, MPL, MRE11A, MSH2, MSH6, MTOR, MUTYH, MYB, MYC, MYCL (MYCL1), MYCN, MYD88, NF1, NF2, NFE2L2, NFKBIA, NKX2-1, NOTCH1, NOTCH2, NOTCH3, NPM1, NRAS, NSD1, NTRK1, NTRK2, NTRK3, NUP93, PAK3, PALB2, PARK2, PAX5, PBRM1, PDCD1LG2, PDGFRA, PDGFRB, PDK1, PIK3C2B, PIK3CA, PIK3CB, PIK3CG, PIK3R1, PIK3R2, PLCG2, PMS2, POLD1, POLE, PPP2R1A, PRDM1, PREX2, PRKAR1A, PRKCI, PRKDC, PRSS8, PTCH1, PTEN, PTPN11, QKI, RAC1, RAD50, RAD51, RAF1, RANBP2, RARA, RB1, RBM10, RET, RICTOR, RNF43, ROS1, RPTOR, RUNX1, RUNX1T1, SDHA, SDHB, SDHC, SDHD, SETD2, SF3B1, SLIT2, SMAD2, SMAD3, SMAD4, SMARCA4, SMARCB1, SMO, SNCAIP, SOCS1, SOX10, SOX2, SOX9, SPEN, SPOP, SPTA1, SRC, STAG2, STAT3, STAT4, STK11, SUFU, SYK, TAF1, TBX3, TERC, TERT (promoter only), TET2, TGFBR2, TMPRSS2, TNFAIP3, TNFRSF14, TOP1, TOP2A, TP53, TSC1, TSC2, TSHR, U2AF1, VEGFA, VHL, WISP3, WT1, XPO1, ZBTB2, ZNF217, ZNF703

```{r, data-prep, include=TRUE, echo = FALSE,warning=FALSE,message=FALSE}

require(rmdformats)
require(rmarkdown)
require(dplyr)
require(forcats)
require(knitr)
require(DT)
require(ggplot2)
require(caret)
require(car)
require(gtsummary)
require(ResourceSelection)
require(pROC)
require(e1071)
require(nnet)
require(glmnet)
require(randomForest)
require(gbm)

genes <- readxl::read_xlsx("testdata.xlsx")

#create subset of relevant variables
genes <- genes %>% 
  select(patientnr = patientNr, gender, yob, 
                           diagnose_group = Diagnose_neu, diagnose = Diagnosis_details_dw, cycle = cycleNr_Test, test_date, result_date,
                           alts_y_n = ALTS_y_n, recs_y_n = Recs_Original_y_n, alteration = all_ALTS, type = ALTS_type, details =ALTS_details
         ) %>% 
  mutate(alts_y_n = ifelse(alts_y_n == "yes",1,0),yob = as.numeric(yob))
  

```

## Dataset

The dataset dimensions are: `r dim(genes)[1]` observations and `r dim(genes)[2]` columns.  <br>

The dataset contains `r length(unique(genes$patientnr))` <br>
- Patients with alterations `r length(unique(subset(genes, alts_y_n == 1)$patientnr))` <br>
- Patients without alterations `r length(unique(subset(genes, alts_y_n == 0)$patientnr))` <br>

The variables part of the dataset are described in more detail in the table below:

| Variable Name   | Description                                                                                          |
|-----------------|------------------------------------------------------------------------------------------------------|
| Patientnr       | unique identifier                                                                                    |
| gender          | gender either "m" male "f" female                                                                    |
| yob             | year of birth, only contains the year in 4 digits                                                    |
| diagnose_group  | diagnosis grouped according to the ICD-10 classification                                             |
| diagnose        | diagnosis, only solid tumor types included                                                           |
| cycle           | number of test, a patient can have multiple                                                          |
| test_date       | Date the test was performed                                                                          |
| result_date     | Date the test report was ready                                                                       |
| alts_y_n        | Did the test identify any alteration yes or no                                                       |
| recs_y_n        | Does the alteration bring specific recommendations yes or no                                         |
| alteration      | Name of different genes                                                                                         |
| type            | Type of alteration found, abbreviated like mut (mutation), amp (amplification), loss                 |
| details         | Details on the specific alteration, this can be for instance a protein                               |

# Data processing

## ICD-10 Groups

Below you find an overview of the data in table format.
```{r, data-pross-header, include=TRUE, echo = FALSE,warning=FALSE,message=FALSE}

#overview of data
datatable(head(genes), options = list(pageLength = 10), caption = "Head of the Genes Dataframe")

#identify rows with missing data
missing_values <- genes %>% filter(if_any(everything(), ~ is.na(.x) & alts_y_n == 1))
#filter out rows with missing values
genes_ <- genes %>% filter(!patientnr %in% missing_values$patientnr)

```

***

Before we can analyze the data we need to get an overview of frequencies and distributions.

```{r, data-pross-diagnosegroups, include=TRUE, echo = FALSE,warning=FALSE,message=FALSE, fig_width=20, fig_height=12}
#show distribution of alterations among ICD10 groups
genes_ %>% 
  mutate(diagnose_group = fct_rev(fct_infreq(diagnose_group))) %>% 
  filter(alts_y_n == 1) %>% 
  ggplot(aes(x = diagnose_group)) + 
  geom_bar(fill = "steelblue") + 
  coord_flip() +
  geom_text(stat = 'count', aes(label = ..count..), hjust = -0.2) +
  ylim(0, 250) +
  labs(x = "ICD-10 Diagnosis groups", y = "Frequency of alterations", caption = "Figure 1: Distribution of alterations among ICD-10 groups") +
  theme_minimal()

```

***

It would seem that some groups are rather small

```{r, data-pross-diagnosegroups-frequency, include=TRUE, echo = FALSE,warning=FALSE,message=FALSE}

#therefore remove groups with low N

# Calculate the counts and percentages
group_summary <- genes_ %>%
  filter(alts_y_n == 1) %>% 
  mutate(fct_infreq(diagnose_group)) %>% 
  count(diagnose_group) %>%
  mutate(percentage = round(n / sum(n) * 100,2 )) %>% 
  arrange(desc(n)) %>% 
  mutate(N = row_number(), .before = diagnose_group)

# Display the table using kable
kable(group_summary, caption = "Counts and Percentages per Diagnose Group")


group_summary_exclude <- group_summary %>% filter(percentage <= 2)
genes_ <- genes %>% filter(!diagnose_group %in% group_summary_exclude$diagnose_group)


```



Before training the model, several preprocessing steps were performed: <br>
- Handling missing values by removing rows with missing data, `r nrow(missing_values)` rows. <br>
- Converting all features to factors to facilitate modeling with a decision tree. <br>
- Removing empty and rare classes to ensure the model's robustness, leaving with `r length(unique(genes_$diagnose_group))` ICD-10 groups.

## Alterations


# Analysis 1: logistic regression


## Occurence of an alteration - logistic regression


### The model
```{r, data-ana-log, include=TRUE, echo = FALSE,warning=FALSE,message=FALSE}

#make factor
genes_$diagnose_group <- fct_infreq(genes_$diagnose_group)
genes_$gender <- factor(genes_$gender)

# Split the data into training and test sets
set.seed(123)  # For reproducibility
trainIndex <- createDataPartition(genes_$alts_y_n, p = 0.7, list = FALSE, times = 1)
trainData <- genes_[trainIndex, ]
testData <- genes_[-trainIndex, ]

testData$diagnose_group <- factor(testData$diagnose_group, levels = levels(trainData$diagnose_group))

# Fit the logistic regression model
model <- glm(alts_y_n ~ diagnose_group + gender + yob, data = trainData, family = binomial)

# Summary of the model
model %>% 
  tbl_regression() %>% 
  bold_labels() %>% 
  bold_p()

```

### Evaluation

```{r, data-ana-log2, include=TRUE, echo = FALSE,warning=FALSE,message=FALSE}

# Predict on test data
predicted_probs <- predict(model, testData, type = "response")
predicted_classes <- ifelse(predicted_probs > 0.5, 1, 0)

# Ensure predicted_classes and testData$alts_y_n are factors with the same levels
testData$alts_y_n <- factor(testData$alts_y_n)  # Ensure testData$alts_y_n is a factor
predicted_classes <- factor(predicted_classes, levels = levels(testData$alts_y_n))

testData$alts_y_n <- factor(testData$alts_y_n, levels = c(0, 1))  # Ensure testData$alts_y_n is a factor with levels 0 and 1
predicted_classes <- factor(predicted_classes, levels = c(0, 1))


# Confusion Matrix
conf_matrix <- confusionMatrix(predicted_classes, testData$alts_y_n)
print(conf_matrix)

# ROC Curve
roc_curve <- roc(as.numeric(testData$alts_y_n), predicted_probs)
plot(roc_curve)
auc(roc_curve)

# Check VIF for multicollinearity
vif(model)

```


Considering the AUC is around 0.55, the model performs no better than random guessing. In addition, the ROC curve closely resembles a stepwise diagonal line, which further supports the poor performance of the model. 

The Variance inflation factor (VIF) is a measure to detect multicollinearity in regression models. High VIF values indicate high multicollinearity between the predictor variables. The number of predictors suggest there is moderate to no multicollinearity between the predictors. 

```{r, data-ana-log3, include=TRUE, echo = FALSE,warning=FALSE,message=FALSE}
# Check linearity of logits
# trainData$logit <- log(predict(model, trainData, type = "response") / (1 - predict(model, trainData, type = "response")))
# ggplot(trainData, aes(y = logit, x = yob)) + 
#   geom_point() + 
#   geom_smooth(method = "loess") + 
#   labs(title = "Linearity of Logits", y = "Logit", x = "Year of Birth")

# Hosmer-Lemeshow test
#hoslem.test(trainData$alts_y_n, fitted(model))


```


# Analysis 2: random forest


## Occurence of an alteration - random forest
```{r, data-ana2-log, include=TRUE, echo = FALSE,warning=FALSE,message=FALSE}


# Check for missing values
#print(sapply(genes_, function(x) sum(is.na(x))))

# Split the data into training and test sets
set.seed(123)  # For reproducibility
trainIndex <- createDataPartition(genes_$alts_y_n, p = 0.7, list = FALSE, times = 1)
trainData <- genes_[trainIndex, ]
testData <- genes_[-trainIndex, ]

# Check for missing values in training and test sets
#print(sapply(trainData, function(x) sum(is.na(x))))
#print(sapply(testData, function(x) sum(is.na(x))))

# Ensure the levels of factors in testData match those in trainData
testData$diagnose_group <- factor(testData$diagnose_group, levels = levels(trainData$diagnose_group))
testData$gender <- factor(testData$gender, levels = levels(trainData$gender))

# Remove rows with missing values
trainData <- na.omit(trainData)
testData <- na.omit(testData)

# train a Random Forest model

train_control <- trainControl(method = "boot", number = 25)

# Train the Random Forest model
rf_model <- train(
  alts_y_n ~ diagnose_group + gender + yob,
  data = trainData,
  method = "rf",
  trControl = train_control,
  tuneLength = 10
)
rf_model

# Get feature importance using varImp
importance <- varImp(rf_model)

# Plot feature importance
plot(importance, top = 18)

```
There are different mtry, number of variables randomly sampled as candidates each split. However, RMSE, Rsquared and MAE are all 0 or NaN. meaning that the model could not be completed. One would normally choose the mtry value where the RMSE and MAE be lower and Rsquared higher for better model fit. 

```{r, data-ana2-log2, include=TRUE, echo = FALSE,warning=FALSE,message=FALSE}

# Make predictions
rf_predictions <- predict(rf_model, testData)

# Convert rf_predictions to a factor with the same levels as testData$Status
rf_predictions <- factor(rf_predictions, levels = c(0,1))

# Ensure testData$Status is a factor (if not already)
testData$alts_y_n <- factor(testData$alts_y_n, levels = c(0,1))

# Generate the confusion matrix
conf_matrix <- confusionMatrix(rf_predictions, testData$alts_y_n)
print(conf_matrix)


```

The confusion matrix: <br>
- True Positives (TP): 0 (model predicted 1, and it was 1). <br>
- True Negatives (TN): 151 (model predicted 1, and it was 1). <br>
- False Positives (FP): 0 (model predicted 0, but it was 1). <br>
- False Negatives (FN): 0 (model predicted 1, but it was 0).<br>

Since there is only one value of both the predictions and reference, which does not leave much to work with. 


# Conclusion and next steps

The question if it is possible to predict the possibility of finding an alteration based on the different ICD-10 groups. 

Both models were no good fit, which might be cause of the dataset or the methods used. The logistic regression did not say any signficant predictor, and the random forest model did not provide more information.

Next steps would be to explore other methods, or consider the dataset inappropriate.







